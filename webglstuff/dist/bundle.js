!function(e){var n={};function r(t){if(n[t])return n[t].exports;var i=n[t]={i:t,l:!1,exports:{}};return e[t].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:t})},r.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="/dist",r(r.s=2)}([function(e,n){e.exports="#define PI 3.14159265358979323844\r\n\r\nuniform float time;\r\nuniform float nofParticles;\r\nuniform float particleSize;\r\nuniform float pixelRatio;\r\n\r\nvarying vec3 particlePosition;\r\nvarying vec4 devianceForFragshader;\r\n\r\nattribute float vertexIndex;\r\nattribute vec4 deviance;\r\n\r\nfloat easeOutCubic(float t) {\r\n  t--;\r\n  return t*t*t + 1.0;\r\n}\r\n\r\nfloat easeInOutCubic(float t) {\r\n  if (t < 0.5) \r\n    return 4.0*t*t*t;\r\n  else \r\n    return (t-1.0)*(2.0*t-2.0)*(2.0*t-2.0)+1.0;\r\n}\r\n\r\nfloat easeInOutQuad(float t) {\r\n  return t < 0.5 ? 2.0*t*t : -1.0+(4.0-2.0*t)*t;\r\n}\r\n\r\nvec2 get2DCoord(float index, float width) {\r\n  float x = mod(vertexIndex, width);\r\n  float y = floor(vertexIndex / width);\r\n\r\n  return vec2(x, y);\r\n}\r\n\r\nvec3 startPosition() {\r\n  float square = floor(sqrt(nofParticles));\r\n\r\n  vec2 coord2D = get2DCoord(vertexIndex, square) - vec2(square/2.0);\r\n\r\n  vec3 gridPosition = vec3(coord2D.x, 0, coord2D.y);\r\n\r\n  float wavelength = 1.0/10.0;\r\n  float wavespeed = 3.0;\r\n  float amplitude = 3.0;\r\n  float wave = amplitude * sin(gridPosition.z*wavelength + time*wavespeed);\r\n\r\n  return vec3(\r\n    gridPosition.x, \r\n    gridPosition.y + wave, \r\n    gridPosition.z\r\n  );\r\n}\r\n\r\nvec3 targetPosition() {\r\n  float width = 20.0;\r\n  float height = 40.0;\r\n  float z = -width/2.0;\r\n  if (deviance.y < 0.03) z -= width;\r\n  if (deviance.y > 0.2) z += width;\r\n\r\n  return vec3(-20.0, 30.0 + deviance.w*height, z + deviance.z*width);\r\n}\r\n\r\nvoid main() {\r\n\r\n  vec3 startPosition = startPosition();\r\n  \r\n  vec3 targetPosition = targetPosition();\r\n\r\n  float movementSpeed = 1.0/2.0;\r\n  float releaseTempo = 1.0/10.0;\r\n  float relativeTime = (time - deviance.x/releaseTempo) * movementSpeed;\r\n  relativeTime = clamp(relativeTime, 0.0, 1.0);\r\n\r\n  vec3 newPosition = mix(startPosition, targetPosition, easeInOutQuad(relativeTime));\r\n\r\n  particlePosition = newPosition;\r\n  devianceForFragshader = deviance;\r\n\r\n  vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);\r\n  \r\n  gl_PointSize = particleSize*pixelRatio/length(mvPosition.xyz);\r\n\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n}"},function(e,n){e.exports="uniform float time;\r\n\r\nvarying vec4 devianceForFragshader;\r\nvarying vec3 particlePosition;\r\n\r\nvec4 circle(vec3 color, vec2 pointCoord) {\r\n  float alpha;\r\n\r\n  float gradient = 1.0 - length(pointCoord - vec2(0.5, 0.5));\r\n  \r\n  if (gradient > 0.5) // TODO: Use ternary\r\n    alpha = 1.0; \r\n  else \r\n    alpha = 0.0;\r\n  \r\n  float gradientWidth = 0.1;\r\n  if (gradient < 0.5 + gradientWidth && gradient > 0.5) \r\n    alpha = 1.0 - (0.5 + gradientWidth - gradient) / gradientWidth;\r\n\r\n  return vec4(color.x, color.y, color.z, alpha);\r\n}\r\n\r\nvoid main() {\r\n  vec3 white = vec3(1.0);\r\n  vec3 green = vec3(0.5, 1.0, 0.5);\r\n  vec3 red = vec3(1.0, 0.25, 0.25);\r\n\r\n  vec3 color = white;\r\n  if (devianceForFragshader.y < 0.03) color = green;\r\n  if (devianceForFragshader.y > 0.2) color = red;\r\n\r\n  gl_FragColor = circle(color, gl_PointCoord);\r\n}"},function(e,n,r){"use strict";r.r(n);var t=r(1),i=r.n(t),o=r(0),a=r.n(o);const d=4e4;let l,c,s,v;const u={time:{value:0},pixelRatio:{value:window.devicePixelRatio},nofParticles:{value:d},particleSize:{value:window.screen.width/4}},f=function(e,n){l=(new Date).getTime(),console.log("initAnimation HEHR",window.innerWidth,window.innerHeight),(s=new THREE.WebGLRenderer({antialias:!1})).gammaInput=!0,s.gammaOutput=!0,s.setClearColor(1907997),s.domElement.setAttribute("id",n),s.setSize(window.innerWidth,window.innerHeight,!0),s.setPixelRatio(window.devicePixelRatio||1);const r=s.getContext().drawingBufferWidth/s.getContext().drawingBufferHeight;(c=new THREE.PerspectiveCamera(60,r,.1,1e4)).position.set(-150,50,0),c.lookAt(new THREE.Vector3(0,0,0)),c.updateProjectionMatrix(),document.getElementById(e).appendChild(s.domElement),v=new THREE.Scene;const t=function(){const e=new Float32Array(3*d),n=new THREE.BufferGeometry;n.addAttribute("position",new THREE.BufferAttribute(e,3));const r=new Float32Array(d);for(let e=0;e<r.length;e++)r[e]=e;n.addAttribute("vertexIndex",new THREE.BufferAttribute(r,1));const t=new Float32Array(4*d);for(let e=0;e<t.length;e++)t[e]=Math.random();return n.addAttribute("deviance",new THREE.BufferAttribute(t,4)),n.computeBoundingSphere(),n}(),o=new THREE.ShaderMaterial({uniforms:u,vertexShader:a.a,fragmentShader:i.a,transparent:!0}),f=new THREE.Points(t,o);v.add(f),g(c,s)};const w=function(){requestAnimationFrame(w),u.time.value=((new Date).getTime()-l)/1e3,s.render(v,c)},g=function(e,n){window.addEventListener("resize",function(){var r=window.innerHeight;n.setSize(window.innerWidth,r),e.aspect=window.innerWidth/r,e.updateProjectionMatrix()})};f("container","renderer"),w()}]);